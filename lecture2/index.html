<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8" /><meta name="author" content="Ivan Ponomarev" /><title>Java Interview: Лекция 2</title><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><link href="reveal.js-3.7.0/css/reveal.css" rel="stylesheet" /><link rel="stylesheet" href="white_course.css" id="theme" /><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="./font-awesome-4.7.0/css/font-awesome.css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js-3.7.0/lib/css/zenburn.css" rel="stylesheet" /><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js-3.7.0/css/print/pdf.css" : "reveal.js-3.7.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js-3.7.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Java Interview</h1><h2>Лекция 2</h2><p class="author"><small>Ivan Ponomarev</small></p></section><section id="_интерфейсы_коллекций_некоторые_реализации_map"><h2>Интерфейсы коллекций: некоторые реализации Map</h2><div class="imageblock" style=""><img src="images/colintf.png" alt="colintf" /></div></section>
<section id="_вопросы"><h2>Вопросы</h2><div class="olist arabic"><ol class="arabic"><li><p>Когда какая из этих мап нужна?</p></li><li><p>Как устроена каждая из мап?</p></li><li><p>Могут ли мутабельные объекты служить ключами мапы?</p></li><li><p>Какова асимптотическая сложность доступа к элементу той или иной мапы?</p></li></ol></div></section>
<section id="_неувядающая_классика_как_работает_hashmap"><h2>Неувядающая классика: как работает HashMap?</h2><div class="imageblock" style=""><img src="images/diag-de17bd6bc5e15e139ccb018b827f0c16.png" alt="diag de17bd6bc5e15e139ccb018b827f0c16" /></div></section>
<section id="_неувядающая_классика_коллизии"><h2>Неувядающая классика: коллизии</h2><div class="imageblock" style=""><img src="images/diag-d71cb67868bffe95b408869679c8972d.png" alt="diag d71cb67868bffe95b408869679c8972d" /></div></section>
<section id="_неувядающая_классика_treeification"><h2>Неувядающая классика: treeification</h2><div class="imageblock" style=""><img src="images/diag-1de2cca622d886df3a887e9b128e4aee.png" alt="diag 1de2cca622d886df3a887e9b128e4aee" /></div></section>
<section id="_произведите_впечатление_на_интервьюера"><h2>Произведите впечатление на интервьюера</h2><div class="paragraph"><p>Расскажите о MapN и linear probing vs chaining</p></div>
<div class="imageblock" style=""><img src="images/diag-9a7e68796eb0b284e909af48d2178b55.png" alt="diag 9a7e68796eb0b284e909af48d2178b55" /></div></section>
<section id="_задачи_на_алгоритмы"><h2>Задачи на алгоритмы</h2><div class="ulist"><ul><li><p>"Реализуйте свой кэш" и прочие задачи на алгоритмы&#8201;&#8212;&#8201;out of scope of this presentation</p></li><li><p>Но к слову о кэшах:</p><div class="ulist"><ul><li><p><code>LinkedHashMap</code>&#8201;&#8212;&#8201;готовый LRU кэш</p></li><li><p>Guava cache</p></li></ul></div></li></ul></div></section>
<section id="_streams_optionals"><h2>Streams &amp; Optionals</h2><div class="ulist"><ul><li><p>Умеем пользоваться стримами:</p><div class="ulist"><ul><li><p>породить стрим перечислением элементов, из коллекции, конкатенацией других стримов&#8230;&#8203;</p></li><li><p>фильтровать <code>filter</code>, <code>limit</code>/<code>takeWhile</code>, <code>skip</code>/<code>dropWhile</code>, <code>distinct</code></p></li><li><p>преобразовать <code>map</code>/<code>flatMap</code></p></li><li><p>выполнить терминальную операцию</p></li></ul></div></li></ul></div></section>
<section id="_терминальные_операции"><h2>Терминальные операции</h2><div class="ulist"><ul><li><p><code>findAny</code> / <code>findFirst</code> (где разница?)</p></li><li><p><code>anyMatch</code> / <code>allMatch</code> / <code>noneMatch</code></p></li><li><p><code>reduce</code> with identity / without identity</p></li><li><p>Collectors API: большая и сложная тема</p></li></ul></div></section>
<section id="_группировки"><h2>Группировки</h2><div class="imageblock" style=""><img src="images/groupby.png.png" alt="groupby.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">List</span>&lt;Dish&gt;&gt; dishesByType =
  menu.stream().collect(Collectors.groupingBy(Dish::getType));</code></pre></section>
<section id="_downstream_collectors"><h2>Downstream Collectors</h2><div class="imageblock" style=""><img src="images/groupbyby.png.png" alt="groupbyby.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">Map</span>&lt;Dish.CaloricLevel, <span class="predefined-type">List</span>&lt;Dish&gt;&gt;&gt;
  dishesByTypeAndCaloricLevel =
    menu.stream().collect(Collectors
      .groupingBy(Dish::getType,
         Collectors.groupingBy(Dish::getCaloricLevel)));</code></pre></section>
<section id="_но_мы_можем_не_только_группировать_в_цепочке"><h2>Но мы можем не только группировать в цепочке!</h2><div class="imageblock" style=""><img src="images/groupbyandcount.png.png" alt="groupbyandcount.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">Long</span>&gt; typesCount =
  menu.stream().collect(Collectors
    .groupingBy(Dish::getType, Collectors.counting()));</code></pre></section>
<section id="_знаем_и_умеем_применять_класс_optional"><h2>Знаем и умеем применять класс Optional</h2><div class="ulist"><ul><li><p>Стрим из 0 или 1 элемента</p></li><li><p>Заменяет nullable-значения</p></li><li><p>Применяется в современных API как возвращаемое значение</p></li><li><p>Всё ещё не решает проблему null safety в Java</p></li></ul></div></section>
<section id="_декларативный_comparator"><h2>Декларативный Comparator</h2><div class="ulist"><ul><li><p>Дан класс <code>Person</code> со свойствами <code>getFirstName()</code>, <code>getLastName()</code>. Как вы отсортируете <code>List&lt;Person&gt;</code> в алфавитном порядке по фамилии (если фамилия совпадает, то по имени)?</p></li></ul></div>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="predefined-type">Collections</span>.sort(people,
  <span class="predefined-type">Comparator</span>
    .comparing(Person::getLastName)
    .thenComparing(Person::getFirstName));
);</code></pre></section>
<section id="_как_улучшить_свои_знания"><h2>Как улучшить свои знания?</h2><div class="ulist"><ul><li><p>Лекция Streams API, Optionals: <a href="https://www.youtube.com/watch?v=NMQ_z8Wlrbw" class="bare">https://www.youtube.com/watch?v=NMQ_z8Wlrbw</a></p></li><li><p>Тагир Валеев:  Используйте Stream API проще (или не используйте вообще) <a href="https://habr.com/ru/articles/337350/" class="bare">https://habr.com/ru/articles/337350/</a></p></li><li><p>Тагир Валеев: Причуды Stream API <a href="https://www.youtube.com/watch?v=1_Zj3gS_a3E" class="bare">https://www.youtube.com/watch?v=1_Zj3gS_a3E</a></p></li></ul></div></section>
<section id="_jdbc_и_базы_данных"><h2>JDBC и базы данных</h2><div class="paragraph"><p>К сожалению, раскрыть это тему не успеваем</p></div>
<div class="ulist"><ul><li><p>SQL надо знать, хотя бы базово с реляционными базами надо уметь обходиться</p></li><li><p>знание JDBC + какой-нибудь прослойки типа Spring JDBC, jOOQ, JPA часто бывает необходимым требованием</p></li></ul></div></section>
<section id="_concurrency"><h2>Concurrency</h2><div class="ulist"><ul><li><p>Базовое понимание, что такое тред.</p></li><li><p>Можем ли мы создать 2000 тредов? Почему?</p></li></ul></div></section>
<section id="_вопросы_по_concurrency"><h2>Вопросы по Concurrency</h2><div class="ulist"><ul><li><p>Что такое Java memory model?</p></li><li><p>Правила JMM</p></li><li><p>Как пользоваться volatile?</p></li><li><p>Как пользоваться synchronized?</p></li><li><p>lock acquire-release, wait-notify</p></li></ul></div></section>
<section id="_модель_памяти"><h2>Модель памяти</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">int</span> aVariable = <span class="integer">42</span>;</code></pre>
<div class="ulist"><ul><li><p>Модель памяти (Java Memory Model, JMM)&#8201;&#8212;&#8201;спецификация языка и виртуальной машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную <code>aVariable</code>, увидит значение 42?»</p></li></ul></div></section>
<section id="_happens_before"><h2>Happens-before</h2><div class="ulist"><ul><li><p>JMM определяет частичный порядок на всех действиях в Java-программе, называемый <em>happens-before</em>.</p></li><li><p>Отношение <em>happens-before</em> транзитивно: \(A \prec B \wedge B \prec C \Rightarrow A \prec C\)</p></li><li><p>Однако не про всякую пару A и B можно сказать, что \(A \prec B\) или \(B \prec A\)&#8201;&#8212;&#8201;т. е. порядок по happens-before <em>частичный</em></p></li><li><p>Чтобы действие B гарантированно видело результат работы действия A, достаточно, чтобы \(A \prec B\).</p></li></ul></div></section>
<section id="_program_order_rule"><h2>Program order rule</h2><div class="ulist"><ul><li><p>В рамках одного треда все действия <em>happens-before</em> в порядке их определения в исходном коде программы.</p></li><li><p>Иными словами, однопоточные программы выполняются без сюрпризов.</p></li></ul></div></section>
<section id="_thread_start_thread_termination_rule"><h2>Thread start &amp; thread termination rule</h2><div class="ulist"><ul><li><p>Вызов <code>threadA.start()</code> <em>happens-before</em> всех операций в потоке <code>threadA</code>.</p></li><li><p>Любая операция в потоке <code>threadA</code> <em>happens-before</em> обнаружения другим потоком завершения <code>threadA</code>, либо путём выхода из <code>threadA.join()</code>, либо путём проверки <code>threadA.isAlive() == false</code>.</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">CalcSquare</span> <span class="directive">extends</span> <span class="predefined-type">Thread</span> {
  <span class="directive">final</span> <span class="type">int</span> argument;
  <span class="type">int</span> result;
  CalcSquare(<span class="type">int</span> argument) {
    <span class="local-variable">this</span>.argument = argument;
  }
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> run() {
    <span class="comment">//«сложные» вычисления</span>
    result = argument * argument;
  }
}</code></pre></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">CalcSquare t1 = <span class="keyword">new</span> CalcSquare(<span class="integer">2</span>);
CalcSquare t2 = <span class="keyword">new</span> CalcSquare(<span class="integer">3</span>);
t1.start();
t2.start();
t1.join();
t2.join();


<span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d, %d%n</span><span class="delimiter">&quot;</span></span>,
  t1.result, t2.result);
<span class="comment">/*output: 4, 9 */</span></code></pre></div></td></tr></table></section>
<section id="_ключевое_слово_volatile"><h2>Ключевое слово volatile</h2><div class="ulist"><ul><li><p>Переменные классов могут быть определены с ключевым словом <code>volatile</code>.</p></li><li><p><strong>Запись в <code>volatile</code>-переменную <em>happens-before</em> чтения из этой переменной в другом потоке.</strong></p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">WayToFallAsleep</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {
  <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> asleep;
  <span class="directive">public</span> <span class="type">void</span> setAsleep(<span class="type">boolean</span> asleep){
    <span class="local-variable">this</span>.asleep = asleep;
  }
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> run() {
    <span class="keyword">while</span> (!asleep){
      <span class="comment">//countSomeSheep</span>
      <span class="comment">//...</span>
    }
  }
}</code></pre></section>
<section id="_чтение_volatile_переменной"><h2>Чтение volatile-переменной</h2><div class="ulist"><ul><li><p>Чтение одной лишь volatile-переменной автоматом делает видимыми изменения в других переменных. Полагаться на это не рекомендуется: это работает, но делает код хрупким. В процессе рефакторинга можно поменять порядок доступа к переменным и тем самым незаметно поломать программу.</p></li></ul></div></section>
<section id="_jmm_monitor_lock_rule"><h2>JMM Monitor Lock Rule</h2><div class="ulist"><ul><li><p>Разблокировка (unlocking) <em>happens-before</em> другой блокировки (locking) того же самого «замка» (lock).</p></li><li><p>Поэтому защищённые блокировкой переменные объявлять как <code>volatile</code> уже не нужно.</p></li></ul></div></section>
<section id="_condition_objects_неувядающая_классика_собеседований"><h2>Condition Objects: неувядающая классика собеседований</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">private</span> <span class="predefined-type">ReentrantLock</span> bankLock = <span class="keyword">new</span> <span class="predefined-type">ReentrantLock</span>();
<span class="directive">private</span> <span class="predefined-type">Condition</span> sufficientFunds = bankLock.newCondition();

<span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
  bankLock.lock();
  <span class="keyword">try</span> {
    <span class="keyword">while</span> (accounts[from] &lt; amount)
      sufficientFunds.await();

    accounts[from]-=amount;
    accounts[to]+=amount;

    sufficientFunds.signalAll();
  } <span class="keyword">finally</span> {
    bankLock.unlock();
  }
}</code></pre></section>
<section id="_condition_objects_что_происходит"><h2>Condition Objects: что происходит?</h2><div class="ulist"><ul><li><p><code>await()</code> отпускает блокировку и переводит тред в ждущее состояние,</p></li><li><p><code>signalAll()</code> сигнализирует всем ждущим тредам, что что-то поменялось,</p></li><li><p>выход из <code>await()</code> <em>снова захватывает блокировку</em>.</p></li><li><p>При выходе из <code>await()</code> мы вновь проверяем условие, потому что:</p><div class="ulist"><ul><li><p>сигнал мог быть по другому поводу,</p></li><li><p>возможны «спонтанные пробуждения».</p></li></ul></div></li></ul></div></section>
<section id="_контрольный_вопрос"><h2>Контрольный вопрос</h2><div class="ulist"><ul><li><p>Чем гарантировано, что при выходе из <code>await()</code> мы увидим изменения, сделанные другим тредом?</p></li></ul></div>
<div class="ulist fragment"><ul><li><p>При выходе из <code>await()</code> мы снова захватываем блокировку, работает JMM Monitor Lock Rule.</p></li></ul></div></section>
<section id="_правильный_паттерн_ожидания_condition"><h2>Правильный паттерн ожидания condition</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">while</span> (!okToProceed())
  condition.await();</code></pre></section>
<section id="_intrinsic_lock"><h2>Intrinsic lock</h2><div class="ulist"><ul><li><p>Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.</p></li><li><p>У каждого intrinsic lock есть один condition.</p></li></ul></div></section>
<section id="_то_же_самое_с_помощью_intrinsic_lock"><h2>То же самое, с помощью intrinsic lock</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//enter intrinsic lock on *this*</span>
<span class="directive">synchronized</span> <span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
    <span class="keyword">while</span> (accounts[from] &lt; amount)
      wait(); <span class="comment">//wait on intrinsic object's lock condition</span>

    accounts[from]-=amount;
    accounts[to]+=amount;

    notifyAll(); <span class="comment">//notify all threads waiting on the condition</span>
}</code></pre></section>
<section id="_intrinsic_conditions"><h2>Intrinsic conditions</h2><div class="ulist"><ul><li><p>Нужно работать по строгому паттерну:</p><div class="ulist"><ul><li><p>синхронизация,</p></li><li><p>while-loop wait,</p></li><li><p>нотификация.</p></li></ul></div></li><li><p>Нужно держать в уме:</p><div class="ulist"><ul><li><p>по intrinsic lock какого объекта синхронизируемся,</p></li><li><p>по condition какого объекта ждём,</p></li><li><p>треды, ждущие на condition какого объекта нотифицируем (это всё должен быть один объект).</p></li></ul></div></li><li><p>В общем, это низкоуровневый и сложный механизм. Его понимание пригодится на собеседованиях, но скорее всего, вам не надо будет им пользоваться.</p></li></ul></div></section>
<section id="_простые_правила_работы_с_concurrency"><h2>"Простые" правила работы с Concurrency</h2><div class="ulist"><ul><li><p>Где возможно, используйте immutable state: он автоматически потокобезопасен.</p></li><li><p>Используйте volatile переменные ИЛИ синхронизацию для доступа к mutable state.</p></li><li><p>Удерживайте блокировку во время выполнения операций, которые должны быть атомарными.</p></li><li><p><strong>Программа с shared mutable state без должной синхронизации&#8201;&#8212;&#8201;сломанная программа</strong>, даже если "это работает на моей машине".</p></li><li><p>Понимание JMM помогает</p></li></ul></div></section>
<section id="_deadlocks"><h2>Deadlocks</h2><div class="ulist"><ul><li><p>Объясните что такое дедлок и мы наймём вас.</p></li></ul></div>
<div class="paragraph fragment"><p>Наймите меня, и я объясню вам, что такое дедлок.</p></div></section>
<section id="_deadlocks_2"><h2>Deadlocks</h2><div class="ulist"><ul><li><p>jstack</p></li><li><p>порядок блокировки</p></li><li><p>если у вас всего один лок, у вас не будет дедлока :-)</p></li></ul></div></section>
<section id="_блокирующие_неблокирующие_структуры_данных"><h2>Блокирующие / неблокирующие структуры данных</h2><div class="ulist"><ul><li><p>lock contention</p></li><li><p>CAS операции</p></li><li><p>классы атомарных переменных и потокобезопасные коллекции, реализованные в том числе на неблокирующих алгоритмах</p></li></ul></div></section>
<section id="_также_нужно_знать_про"><h2>Также нужно знать про</h2><div class="ulist"><ul><li><p>Тред пулы (Executor Framework)</p></li><li><p>CompletableFuture</p></li><li><p>Кооперативный механизм прерывания (в частности, что делать с <code>InterruptedException</code>)</p></li></ul></div></section>
<section id="_синглетоноварение_подход_1"><h2>Синглетоноварение: подход №1</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
  <span class="comment">//Создание Singleton &quot;спрятано&quot;</span>
  <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Singleton instance = <span class="keyword">new</span> Singleton();

  <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
    <span class="keyword">return</span> instance;
  }

  <span class="comment">//Лишаем возможности создать экземпляр объекта &quot;извне&quot;</span>
  <span class="directive">private</span> Singleton(){
  }
}</code></pre>
<div class="paragraph fragment"><p>"Тяжёлый" объект создаётся всегда, даже если <code>getInstance</code> не будет вызван?</p></div></section>
<section id="_подход_2"><h2>Подход №2</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> Singleton instance;

    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>) {
           instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
    <span class="directive">private</span> Singleton(){
    }
}</code></pre>
<div class="paragraph fragment"><p>Что с многопоточным доступом к переменной <code>instance</code>?</p></div></section>
<section id="_подход_3"><h2>Подход №3 ?!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> Singleton instance;

    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
    <span class="directive">private</span> Singleton(){
    }
}</code></pre>
<div class="paragraph fragment"><p>Теперь нет гарантии, что экземпляр создаётся только один раз!</p></div></section>
<section id="_подход_4"><h2>Подход №4 ?! ?!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> Singleton instance;

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">synchronized</span> Singleton getInstance() {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
    <span class="directive">private</span> Singleton(){
    }
}</code></pre>
<div class="paragraph fragment"><p>Все потоки будут выстраиваться в очередь, только чтобы получить доступ к переменной instance?</p></div></section>
<section id="_подход_5"><h2>Подход №5 ?! ?! ?!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> Singleton instance;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
            <span class="directive">synchronized</span> (lock) {
                <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
                    instance = <span class="keyword">new</span> Singleton();
            }
        <span class="keyword">return</span> instance;
    }
    <span class="directive">private</span> Singleton() {
    }
}</code></pre>
<div class="paragraph fragment"><p>Программа сломана. Из-за того, что в первом <code>if</code>-е чтение поля <code>instance</code> не синхронизировано, возможно чтение частично инициализированного объекта (если конструктор <code>Singleton</code> заинлайнен).</p></div></section>
<section id="_подход_6"><h2>Подход №6 . . .</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> Singleton instance;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
            <span class="directive">synchronized</span> (lock) {
                <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
                    instance = <span class="keyword">new</span> Singleton();
            }
        <span class="keyword">return</span> instance;
    }
    <span class="directive">private</span> Singleton() {
    }
}</code></pre>
<div class="paragraph fragment"><p>Ну, почти. Только у нас оверхед, потому что два раза читаем <code>volatile</code>-переменную.</p></div></section>
<section id="_подход_7_код_из_книги_effective_java_3rd_edition"><h2>Подход №7. Код из книги "Effective Java, 3rd edition"</h2><div class="paragraph"><p>Joshua Bloch: "On my machine, this method is about 1.4 times as fast as the obvious version without a local variable". [EJ, 3rd ed., pp. 334-335]</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
  <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> Singleton instance;
  <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
  <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
    Singleton result = instance;
    <span class="keyword">if</span> (result == <span class="predefined-constant">null</span>) {
      <span class="directive">synchronized</span> (lock) {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
          instance = result = <span class="keyword">new</span> Singleton();
        }
     }
     <span class="keyword">return</span> result;
  }
}</code></pre></section>
<section id="_подход_7_код_из_книги_effective_java_3rd_edition_2"><h2>Подход №7. Код из книги "Effective Java, 3rd edition"</h2><div class="paragraph"><p>Вы уже видите баг в этом коде?<br />
&#160;</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
  <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> Singleton instance;
  <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
  <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
    Singleton result = instance;
    <span class="keyword">if</span> (result == <span class="predefined-constant">null</span>) {
      <span class="directive">synchronized</span> (lock) {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
          instance = result = <span class="keyword">new</span> Singleton();
        }
     }
     <span class="keyword">return</span> result;
  }
}</code></pre>
<div class="paragraph fragment"><p>Если при входе в <code>synchronized</code>-блок <code>instance != null</code>, на выходе&#8201;&#8212;&#8201;<code>null</code>.</p></div></section>
<section id="_единственно_верный_ленивый_потокобезопасный_синглетон"><h2>Единственно Верный Ленивый Потокобезопасный Синглетон</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> Singleton instance;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        Singleton result = instance;
        <span class="keyword">if</span> (result != <span class="predefined-constant">null</span>)
            <span class="keyword">return</span> result;

        <span class="directive">synchronized</span> (lock) {
            <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>)
                instance = <span class="keyword">new</span> Singleton();
            <span class="keyword">return</span> instance;
        }
    }
    <span class="directive">private</span> Singleton() {}
}</code></pre>
<div class="paragraph fragment"><p>Или нет?</p></div></section>
<section id="_подход_8"><h2>Подход №8</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">// Correct lazy initialization in Java</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Singleton</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">SingletonHolder</span> {
       <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Singleton instance = <span class="keyword">new</span> Singleton();
    }

    <span class="directive">public</span> <span class="directive">static</span> Singleton getInstance() {
        <span class="keyword">return</span> SingletonHolder.instance;
    }
    <span class="directive">private</span> Singleton() {
    }
}</code></pre></section>
<section id="_code_review_checklist_java_concurrency"><h2>Code Review Checklist: Java Concurrency</h2><div class="ulist"><ul><li><p><strong>Roman Leventov</strong>: <a href="https://github.com/code-review-checklists/java-concurrency">Code Review Checklist: Java Concurrency</a></p></li><li><p>Порядка 100 пунктов, по которым можно проверить concurrency код на распространённые ошибки</p></li></ul></div></section>
<section id="_spring"><h2>Spring</h2><div class="ulist"><ul><li><p>Что такое бины?</p></li><li><p>как работает DI?</p></li></ul></div>
<div class="paragraph fragment"><p><em>Spring beans</em>&#8201;&#8212;&#8201;это переиспользуемые программные компоненты, автоматически подставляемые (Autowiring) в поля и параметры конструктора других бинов. В качестве бина можно использовать любой класс, как собственный, так и из сторонней библиотеки.</p></div></section>
<section id="_виды_injection_впрыскивания"><h2>Виды injection («впрыскивания»)</h2><div class="ulist"><ul><li><p>Constructor</p></li><li><p>Setter</p></li><li><p>Field</p></li><li><p>Lookup method</p></li></ul></div>
<div class="paragraph"><p>Хороший вопрос: когда какие виды injection лучше использовать?</p></div></section>
<section id="_bean_scopes"><h2>Bean scopes</h2><div class="ulist"><ul><li><p><code>SCOPE_SINGLETON</code>&#8201;&#8212;&#8201;по умолчанию. Создаётся один при первом запросе и всюду впрыскивается единственный экземпляр.</p></li><li><p><code>SCOPE_PROTOTYPE</code>&#8201;&#8212;&#8201;создаётся новый при каждом запросе.</p></li><li><p>Есть ещё всякие, и можно создавать свои.</p></li></ul></div></section>
<section id="_использование_prototype_bean_внутри_синглетона"><h2>Использование prototype-bean внутри синглетона</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Bar</span> {...}

<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {
    <span class="annotation">@Autowired</span>
    <span class="directive">private</span> Bar bar;

    <span class="directive">public</span> <span class="type">void</span> bar(){
        <span class="comment">//заинжектированный экземпляр bar всегда один и тот же</span>
    }
}</code></pre></section>
<section id="_способ_1"><h2>Способ №1</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {
    <span class="annotation">@Autowired</span>
    <span class="directive">private</span> <span class="predefined-type">ObjectFactory</span>&lt;Bar&gt; barFactory;

    <span class="directive">public</span>  <span class="type">void</span> bar(){
      <span class="comment">//теперь в b будет всякий раз новое (ну или одно и то же,</span>
      <span class="comment">//если убрать SCOPE_PROTOTYPE, хотя где тогда смысл?)</span>
        Bar bar = barFactory.getObject();
        ...
    }
}</code></pre></section>
<section id="_способ_2"><h2>Способ №2</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Foo</span> {
  <span class="annotation">@Lookup</span>
  <span class="directive">abstract</span> Bar getBar();

  <span class="directive">public</span>  <span class="type">void</span> bar(){
    Bar b = getBar();

  }
}</code></pre></section>
<section id="_aop_реализация_через_proxy_объект"><h2>AOP: реализация через Proxy-объект</h2><div class="imageblock" style=""><img src="images/proxy.png.png" alt="proxy.png" /></div></section>
<section id="_неувядающая_классика"><h2>Неувядающая классика</h2><div class="paragraph"><p>вызов <code>@Tranasctional</code> из самого бина</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

    <span class="directive">public</span> <span class="type">void</span> doSomething() {
        <span class="comment">// ...</span>
        doSomethingElse();
    }

    <span class="comment">//Transactional тут не работает... :-(((</span>
    <span class="annotation">@Transactional</span>
    <span class="directive">public</span> <span class="type">void</span> doSomethingElse() {
        <span class="comment">// ...</span>
    }
}</code></pre></section>
<section id="_workaround"><h2>Workaround</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

    <span class="annotation">@Autowired</span>
    <span class="predefined-type">ObjectFactory</span>&lt;MyService&gt; self;

    <span class="directive">public</span> <span class="type">void</span> doSomething() {
        <span class="comment">// ...</span>
        self.getObject().doSomethingElse();
    }

    <span class="annotation">@Transactional</span>
    <span class="directive">public</span> <span class="type">void</span> doSomethingElse() {
        <span class="comment">// ...</span>
    }
}</code></pre></section>
<section id="_жизненный_цикл_бина"><h2>Жизненный цикл бина</h2><div class="imageblock" style=""><img src="images/predestroy.png.png" alt="predestroy.png" /></div></section>
<section id="_beanpostprocessor_interface"><h2>BeanPostProcessor interface</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanPostProcessor</span> {
  <span class="comment">//впрыскиваем в бин значения</span>
  <span class="keyword">default</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization(
    <span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) <span class="directive">throws</span> BeansException {
                <span class="keyword">return</span> bean;
  }

  <span class="comment">//возвращаем обёртку над бином</span>
  <span class="keyword">default</span> <span class="predefined-type">Object</span> postProcessAfterInitialization(
    <span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) <span class="directive">throws</span> BeansException {
                <span class="keyword">return</span> bean;
  }
}</code></pre></section>
<section id="_beanpostprocessor"><h2>BeanPostProcessor</h2><div class="imageblock" style=""><img src="images/bpp.png.png" alt="bpp.png" /></div></section>
<section id="_thanks_for_listening"><h2>Thanks for listening!</h2><div class="paragraph"><p><span class="icon"><i class="fa fa-envelope fa-lg"></i></span> <a href="mailto:ivan@synthesized.io">ivan@synthesized.io</a></p></div>
<div class="paragraph"><p><span class="icon"><i class="fa fa-twitter fa-lg"></i></span> @inponomarev</p></div></section></div></div><script src="reveal.js-3.7.0/lib/js/head.min.js"></script><script src="reveal.js-3.7.0/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'none',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1600,
  height: 900,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js-3.7.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'reveal.js-3.7.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js-3.7.0/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>